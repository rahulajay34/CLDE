{
  "version_id": "b5a620a8",
  "timestamp": "2026-01-20 14:37:52",
  "topic": "Fast API",
  "mode": "Lecture Notes",
  "content": "# FastAPI Fundamentals\n\n## What You'll Learn\n\n- **Build** a working REST API with FastAPI that handles HTTP requests and returns JSON responses\n- **Explain** how FastAPI uses Python type hints to automatically validate data and generate documentation\n- **Apply** path parameters, query parameters, and request bodies to create flexible API endpoints\n- **Compare** synchronous and asynchronous request handling to choose the right approach for your use cases\n\n## FastAPI Essentials\n\n### What Is FastAPI?\n\nFastAPI is a modern Python web framework designed specifically for building APIs quickly with automatic data validation and interactive documentation.\n\nAPIs allow different software systems to communicate. FastAPI makes creating these communication channels straightforward using standard Python features. When someone makes a request to your API, FastAPI automatically checks if the data is valid, converts it to the right format, and generates documentation showing others how to use your API\u2014all based on how you write your Python code.\n\n### Why It Matters\n\nWithout a framework like FastAPI, building an API means writing hundreds of lines of repetitive code. You'd manually check every piece of incoming data, convert strings to numbers, validate email formats, and write documentation by hand. When requirements change, you'd update code in multiple places and hope you didn't miss anything.\n\nFastAPI solves this by using Python's type hints as a single source of truth. Write `user_id: int` once, and FastAPI automatically validates that incoming requests contain an integer, rejects invalid data with helpful error messages, and documents this requirement in your API docs.\n\nThis matters when building any backend service: a mobile app that needs data from a server, a microservice that other systems call, or a data pipeline that exposes results through an API. A typical REST API endpoint that validates user input might require 15-20 lines of manual validation code; FastAPI reduces this to a single type hint, eliminating boilerplate and the bugs that come with repetitive code.\n\n## Core Concepts\n\n### Your First FastAPI Application\n\nThe simplest possible API looks like this:\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/\")\ndef read_root():\n    return {\"message\": \"Hello World\"}\n```\n\nThis five-line program creates a complete web server. `FastAPI()` creates your application instance. The `@app.get(\"/\")` decorator tells FastAPI to run `read_root()` when someone visits the root URL with a GET request. The function returns a Python dictionary, and FastAPI automatically converts it to JSON.\n\nRun this with `uvicorn main:app --reload` and visit `http://localhost:8000`. You'll see your JSON response. Visit `http://localhost:8000/docs` and you'll find interactive documentation that FastAPI generated automatically.\n\n### Path Parameters: Dynamic URLs\n\nReal APIs need to handle dynamic data. Path parameters capture values directly from the URL:\n\n```python\n@app.get(\"/users/{user_id}\")\ndef get_user(user_id: int):\n    return {\"user_id\": user_id, \"name\": \"John Doe\"}\n```\n\nThe curly braces `{user_id}` mark a path parameter. The type hint `user_id: int` tells FastAPI to validate that incoming requests contain an integer. Visit `/users/123` and you get a valid response. Try `/users/abc` and FastAPI automatically returns a detailed error message explaining that it expected an integer.\n\nThis automatic validation prevents bugs before they happen. Without it, you'd write code like this:\n\n```python\n# Without FastAPI - error-prone and repetitive\ndef get_user(user_id):\n    try:\n        user_id = int(user_id)\n    except ValueError:\n        return {\"error\": \"user_id must be an integer\"}\n    # Now actually do something with user_id\n```\n\nFastAPI eliminates this boilerplate entirely.\n\n### Query Parameters: Optional Filters\n\nQuery parameters appear after the `?` in URLs like `/items?skip=0&limit=10`. They're perfect for optional filters and pagination:\n\n```python\n@app.get(\"/items\")\ndef list_items(skip: int = 0, limit: int = 10):\n    items = [\"item1\", \"item2\", \"item3\", \"item4\", \"item5\"]\n    return items[skip : skip + limit]\n```\n\nAny function parameter that isn't in the path becomes a query parameter. The default values (`= 0` and `= 10`) make these parameters optional. Call `/items` without parameters and you get the first 10 items. Call `/items?skip=2&limit=2` and you get items starting from position 2.\n\nFastAPI validates types here too. Try `/items?skip=two` and you'll get a clear error explaining the problem.\n\n### Request Bodies: Accepting Complex Data\n\nWhen clients need to send structured data to your API, you use request bodies. FastAPI integrates with Pydantic, a library that makes it easy to define and validate data structures:\n\n```python\nfrom pydantic import BaseModel\n\nclass User(BaseModel):\n    username: str\n    email: str\n    age: int\n\n@app.post(\"/users\")\ndef create_user(user: User):\n    return {\"message\": f\"Created user {user.username}\"}\n```\n\nThe `User` class defines the expected structure. When a POST request arrives, FastAPI automatically validates that the JSON body contains the required fields with correct types. Send invalid data and you get detailed error messages listing exactly what's wrong.\n\nValidation rules live with your data model. Add `age: int` and FastAPI ensures age is an integer. Change it to `age: Optional[int] = None` and age becomes optional. Your validation logic updates automatically.\n\n### Response Models: Controlling Output\n\nResponse models control exactly what clients see in your API responses:\n\n```python\nclass UserIn(BaseModel):\n    username: str\n    password: str\n    email: str\n\nclass UserOut(BaseModel):\n    username: str\n    email: str\n\n@app.post(\"/users\", response_model=UserOut)\ndef create_user(user: UserIn):\n    return user\n```\n\nEven though the function returns the full `UserIn` object with password, the `response_model=UserOut` parameter ensures FastAPI filters out the password before sending the response. This prevents accidental data leaks.\n\n### Async Operations: Handling Many Requests\n\nFastAPI supports both synchronous and asynchronous code. For I/O-bound operations like database queries or API calls, async lets your server handle many requests concurrently:\n\n```python\n@app.get(\"/slow-data\")\nasync def get_slow_data():\n    await some_database_query()\n    await some_external_api_call()\n    return {\"data\": \"result\"}\n```\n\nThe `async def` and `await` keywords tell Python this function can pause while waiting for I/O. While waiting for the database, FastAPI can handle other requests. This dramatically improves throughput for I/O-heavy applications.\n\nUsing `async def` for CPU-intensive work doesn't help. Async benefits I/O operations, not calculations. For heavy computation, use regular `def` functions or background tasks.\n\n```mermaid\ngraph TD\n    A[Client Request] --> B{Async or Sync?}\n    B -->|async def| C[I/O Operation]\n    B -->|def| D[CPU Operation]\n    C --> E[Server handles other requests while waiting]\n    D --> F[Server blocked until complete]\n    E --> G[Response]\n    F --> G\n```\n\n### Dependency Injection: Reusable Logic\n\nFastAPI's dependency injection system lets you reuse common logic across endpoints. Here's authentication as an example:\n\n```python\nfrom fastapi import Depends, HTTPException\n\ndef get_current_user(token: str):\n    if token != \"secret-token\":\n        raise HTTPException(status_code=401, detail=\"Invalid token\")\n    return {\"username\": \"john\"}\n\n@app.get(\"/protected\")\ndef protected_route(user: dict = Depends(get_current_user)):\n    return {\"message\": f\"Hello {user['username']}\"}\n```\n\nThe `Depends(get_current_user)` tells FastAPI to call `get_current_user` first and pass its result to `protected_route`. If `get_current_user` raises an exception, the main function never runs. This keeps your endpoint functions clean and focused.\n\nYou can chain dependencies too. A database session dependency might depend on a configuration dependency, which depends on environment variables. FastAPI handles the entire chain automatically.\n\n## Key Takeaways\n\nYou don't always need Pydantic models. For simple cases with basic types like `int` and `str`, path and query parameters work fine. Use Pydantic models when you're accepting or returning structured data with multiple fields.\n\nUse async for operations that wait on external resources: databases, file systems, network requests. Use regular functions for pure computation, data transformation, or when using libraries that don't support async.\n\nFastAPI returns whatever you return from your function. Return a dictionary or Pydantic model for JSON. If you're seeing HTML, you might be returning a string or hitting the wrong endpoint.\n\nAlways run your development server with `--reload` so changes appear immediately. The interactive docs at `/docs` are invaluable for testing endpoints without writing client code. Type hints are your friend\u2014the more specific your types, the better FastAPI can validate and document your API. `items: List[str]` is better than `items: list`, which is better than no type hint at all.\n\nBuild incrementally. Get a basic endpoint working, then add validation, then add database integration, then add authentication. Building incrementally prevents overwhelming debugging sessions.\n\nFastAPI uses Python type hints as the foundation for automatic validation, serialization, and documentation. Path parameters capture dynamic URL segments, query parameters handle optional filters, and request bodies accept complex structured data through Pydantic models. Async functions improve throughput for I/O-bound operations by letting the server handle multiple requests concurrently while waiting for databases or external APIs. Dependencies inject reusable logic like authentication and database sessions into endpoints, keeping your code clean and maintainable.\n\nThese fundamentals prepare you for more advanced topics like database integration with SQLAlchemy, background tasks for long-running operations, and WebSocket support for real-time features. Each builds on the request-response cycle you've mastered here.",
  "summary": "Finalized Generation"
}