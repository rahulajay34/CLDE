{
  "version_id": "501b9285",
  "timestamp": "2026-01-20 14:40:36",
  "topic": "Fast API",
  "mode": "Assignment",
  "content": "[\n  {\n    \"question_text\": \"In FastAPI, you need to create an endpoint that accepts a user ID from the URL path and a query parameter for filtering results. Which of the following correctly implements this requirement?\",\n    \"options\": [\n      \"@app.get('/users/{user_id}')\\nasync def get_user(user_id: int, filter: str = Query(None)):\\n    return {'user_id': user_id, 'filter': filter}\",\n      \"@app.get('/users/{user_id}')\\nasync def get_user(user_id: int, filter: str):\\n    return {'user_id': user_id, 'filter': filter}\",\n      \"@app.get('/users/')\\nasync def get_user(user_id: int = Path(...), filter: str = Query(None)):\\n    return {'user_id': user_id, 'filter': filter}\",\n      \"@app.get('/users/{user_id}')\\nasync def get_user(user_id: str, filter: str = Query(...)):\\n    return {'user_id': user_id, 'filter': filter}\"\n    ],\n    \"correct_option_index\": 1,\n    \"explanation\": \"Option 1 is correct because it properly defines a path parameter {user_id} in the route decorator, declares it as an integer in the function signature, and uses Query(None) to make the filter parameter optional. The path parameter is automatically extracted from the URL path, while Query(None) explicitly marks filter as an optional query parameter with a default value of None. Option 2 is incorrect because filter is declared as a required parameter without Query(), which would cause issues when the query parameter is not provided. Option 3 is incorrect because it doesn't include {user_id} in the path string, and using Path(...) without the path variable in the route is invalid. Option 4 is incorrect because it declares user_id as a string instead of int (losing type validation benefits) and makes filter required with Query(...), which contradicts the requirement for optional filtering.\",\n    \"difficulty\": \"Medium\",\n    \"type\": \"mcsc\"\n  },\n  {\n    \"question_text\": \"When using Pydantic models for request validation in FastAPI, what happens when a client sends a POST request with a JSON body that contains extra fields not defined in the Pydantic model?\",\n    \"options\": [\n      \"FastAPI returns a 422 Unprocessable Entity error and rejects the request\",\n      \"FastAPI accepts the request but ignores the extra fields by default\",\n      \"FastAPI accepts the request and stores extra fields in a special __extra__ attribute\",\n      \"FastAPI returns a 400 Bad Request error with details about the unexpected fields\"\n    ],\n    \"correct_option_index\": 2,\n    \"explanation\": \"By default, Pydantic models in FastAPI ignore extra fields that are not defined in the model schema. When a request contains additional fields beyond those specified in the model, FastAPI validates and parses only the defined fields and silently discards the rest. This behavior allows for flexible API evolution and backward compatibility. Option 1 is incorrect because FastAPI only returns 422 errors for validation failures on defined fields (wrong type, missing required fields, etc.), not for extra fields. Option 3 is incorrect because extra fields are not stored anywhere by default; they are simply ignored. To store extra fields, you would need to explicitly configure the model with Config.extra = 'allow'. Option 4 is incorrect because 400 errors are typically for malformed requests (like invalid JSON syntax), not for extra fields, and FastAPI doesn't reject requests based on extra fields by default.\",\n    \"difficulty\": \"Medium\",\n    \"type\": \"mcsc\"\n  },\n  {\n    \"question_text\": \"You are building a FastAPI application that needs to perform database connection setup before handling requests and cleanup after shutdown. Which combination of FastAPI features should you use?\",\n    \"options\": [\n      \"Use @app.on_event('startup') and @app.on_event('shutdown') decorators to define lifecycle event handlers\",\n      \"Use @app.before_request() and @app.after_request() decorators similar to Flask\",\n      \"Use dependency injection with Depends() and yield to manage connection lifecycle for each request\",\n      \"Use middleware with @app.middleware('http') to handle setup and cleanup\"\n    ],\n    \"correct_option_index\": 1,\n    \"explanation\": \"The @app.on_event('startup') and @app.on_event('shutdown') decorators are specifically designed for application-level lifecycle management in FastAPI. The startup event runs once when the application starts, making it ideal for initializing database connections, loading configuration, or setting up connection pools. The shutdown event runs once when the application terminates, perfect for closing connections and cleanup. This ensures resources are initialized once and shared across all requests. Option 2 is incorrect because FastAPI doesn't have @app.before_request() or @app.after_request() decorators; those are Flask-specific patterns. Option 3, while valid for per-request resource management using dependency injection with yield, is not appropriate for application-level setup that should happen once at startup rather than for every request. Option 4 is incorrect because middleware runs for each request and is designed for request/response processing, not for one-time application startup and shutdown tasks.\",\n    \"difficulty\": \"Medium\",\n    \"type\": \"mcsc\"\n  },\n  {\n    \"question_text\": \"Which of the following statements about FastAPI's dependency injection system are correct?\",\n    \"options\": [\n      \"Dependencies can be declared using the Depends() function in path operation parameters\",\n      \"Dependencies are always executed synchronously, even if they are async functions\",\n      \"Dependencies can be used to share database connections, authentication logic, and common parameters\",\n      \"Sub-dependencies are not supported in FastAPI's dependency injection system\"\n    ],\n    \"correct_option_indices\": [\n      1,\n      3\n    ],\n    \"explanation\": \"FastAPI's dependency injection system uses the Depends() function to declare dependencies in path operation parameters, making option 1 correct. Dependencies can be used for various purposes including sharing database connections, implementing authentication logic, and handling common parameters across multiple endpoints, making option 3 correct. Option 2 is incorrect because FastAPI supports both synchronous and asynchronous dependencies - async dependencies are executed asynchronously using await. Option 4 is incorrect because FastAPI fully supports sub-dependencies, where dependencies can themselves have dependencies, creating a dependency tree that FastAPI resolves automatically.\",\n    \"difficulty\": \"Medium\",\n    \"type\": \"mcmc\"\n  },\n  {\n    \"question_text\": \"Which of the following are valid ways to define response models in FastAPI?\",\n    \"options\": [\n      \"Using the response_model parameter in the path operation decorator\",\n      \"Using Pydantic models with the response_model parameter to automatically validate and serialize output data\",\n      \"Setting response_model_exclude_unset=True to exclude fields that were not explicitly set\",\n      \"Response models can only return dictionary objects, not Pydantic model instances\"\n    ],\n    \"correct_option_indices\": [\n      1,\n      2,\n      3\n    ],\n    \"explanation\": \"The response_model parameter in path operation decorators (like @app.get()) is the standard way to define response models in FastAPI, making option 1 correct. Pydantic models are used with response_model to automatically validate output data and serialize it to JSON, ensuring type safety and automatic documentation, making option 2 correct. The response_model_exclude_unset parameter can be set to True to exclude fields from the response that were not explicitly set, which is useful for partial updates and optional fields, making option 3 correct. Option 4 is incorrect because FastAPI can return various types including Pydantic model instances, dictionaries, lists, and other serializable objects - the response_model handles the conversion automatically.\",\n    \"difficulty\": \"Medium\",\n    \"type\": \"mcmc\"\n  },\n  {\n    \"question_text\": \"Which statements correctly describe FastAPI's automatic API documentation features?\",\n    \"options\": [\n      \"FastAPI automatically generates interactive API documentation using Swagger UI at the /docs endpoint\",\n      \"ReDoc documentation is automatically available at the /redoc endpoint\",\n      \"The OpenAPI schema must be manually written in JSON format for documentation to work\",\n      \"Path operation parameters, request bodies, and response models are automatically included in the generated documentation\"\n    ],\n    \"correct_option_indices\": [\n      1,\n      2,\n      4\n    ],\n    \"explanation\": \"FastAPI automatically generates interactive Swagger UI documentation accessible at the /docs endpoint by default, making option 1 correct. It also provides ReDoc documentation at the /redoc endpoint as an alternative documentation interface, making option 2 correct. FastAPI automatically includes all path operation parameters, request bodies defined with Pydantic models, and response models in the generated documentation without any manual configuration, making option 4 correct. Option 3 is incorrect because FastAPI automatically generates the OpenAPI schema based on your Python code, type hints, and Pydantic models - no manual JSON writing is required. The framework uses Python type annotations and decorators to automatically create the complete OpenAPI specification.\",\n    \"difficulty\": \"Medium\",\n    \"type\": \"mcmc\"\n  }\n]",
  "summary": "Finalized Generation"
}